import networkx as nx
import matplotlib.pyplot as plt

'''
用于操作码调用图的实现；

一个操作码调用图由226个操作码节点，以及他们之间的调用关系为边来组成，如果有重复边，考虑以增加他们之间的权重为标记

不考虑函数间调用：一个函数对应一个操作码调用图

考虑函数间调用：两种实现：
（1）一个apk对应一个操作码调用图，仍然以226个操作码节点，以及他们之间的调用关系为边组成；
（2）一个apk对应一个操作码调用图，这里考虑另一篇论文的实现方法，以未跳转的块为节点，如果出现跳转则设置为边；
'''



'''
生成一个所有操作码的列表
'''
all_opcode_list = []
jump_opcode_list = []
def get_opcode(all_opcode_path, jump_opcode_path):
    all_f = open(all_opcode_path, 'r', encoding="gbk")
    for opcode in all_f:
        opcode = opcode.strip().replace("\n", "")
        all_opcode_list.append(opcode)
    all_f.close()

    jump_f = open(jump_opcode_path, 'r', encoding="gbk")
    for opcode in jump_f:
        opcode = opcode.strip().replace("\n", "")
        jump_opcode_list.append(opcode)
    jump_f.close()


'''
不考虑函数间调用的实现
输入为一个函数的行列表,不包括.method 和 .end method
输出为一个调用图
'''
def single_opcode_graph_generator(method_line_list):
    # method对应的操作码图
    opcode_graph = nx.DiGraph()
    # 跳转标签的列表
    label_list = []
    # 表示接下来遍历到的pswitch是否是标签
    is_packed_switch = False
    # 表示上一个操作码
    last_opcode = ''
    for line in method_line_list:
        line = line.strip().replace("\n", "")
        line_list = line.split(" ")

        line_length = len(line_list)
        # 先判断是否是一个操作码
        if line_list[0] in all_opcode_list:
            # 有前置节点
            if last_opcode != '':
                # 然后判断是否是跳转操作码,包含两类，goto,if和switch
                if line_list[0] in jump_opcode_list:
                    # 是否是if跳转
                    if line_list[0].startswith("if-"):
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = line_list[0]
                    # 是否是goto跳转
                    elif line_list[0].startswith("goto"):
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = ''
                    # 是否是switch跳转
                    elif line_list[0].startswith("packed-switch"):
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        last_opcode = line_list[0]
                # 非跳转操作码操作
                elif line_list[0].startswith("return"):
                    opcode_graph.add_edge(last_opcode, line_list[0])
                    last_opcode = ''
                else:
                    opcode_graph.add_edge(last_opcode, line_list[0])
                    last_opcode = line_list[0]
            # 没有前置节点
            else:
                # 然后判断是否是跳转操作码,包含两类，goto和if，switch正常按照其他操作码进行处理
                if line_list[0] in jump_opcode_list:
                    # 是否是if跳转
                    if line_list[0].startswith("if-"):
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = line_list[0]
                    # 是否是goto跳转
                    elif line_list[0].startswith("goto"):
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = ''
                elif line_list[0].startswith("return"):
                    last_opcode = ''
                # 非跳转操作码操作
                else:
                    last_opcode = line_list[0]

        # 不是一个操作码
        elif check_is_label(line_list[0]):
            if line_list[0] not in label_list:
                label_list.append(line_list[0])
            # 先看是否有前置节点
            if last_opcode != '':
                # 再看是否是switch标签类型
                if line_list[0].startswith(":pswitch"):
                    if is_packed_switch:
                        opcode_graph.add_edge("packed-switch", line_list[0])
                    else:
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        last_opcode = line_list[0]
                # 其他正常处理
                else:
                    opcode_graph.add_edge(last_opcode, line_list[0])
                    last_opcode = line_list[0]
            # 没有前置节点
            else:
                # 再看是否是switch标签类型
                if line_list[0].startswith(":pswitch_"):
                    if is_packed_switch:
                        opcode_graph.add_edge("packed-switch", line_list[0])
                    else:
                        last_opcode = line_list[0]
                # 其他正常处理
                else:
                    last_opcode = line_list[0]
        elif line_list[0].startswith(".packed-switch"):
            is_packed_switch = True
            continue
        elif line_list[0].startswith(".end packed-switch"):
            is_packed_switch = False
            continue
    # print_opcode_graph(opcode_graph)

    # 删除label，调用label的操作码指向label的下一个节点
    for label in label_list:
        pre_list = []
        next_list = []
        presuccessors = opcode_graph.predecessors(label)
        # 调用点
        successors = opcode_graph.successors(label)
        # 将被调用点指向调用点
        for presuccessor in presuccessors:
            pre_list.append(presuccessor)

        for successor in successors:
            next_list.append(successor)

        for pre_node in pre_list:
            for next_node in next_list:
                opcode_graph.add_edge(pre_node, next_node)
        # 删除节点
        opcode_graph.remove_node(label)

    return opcode_graph

'''
考虑函数间调用的实现,具体应用为考虑函数间调用的第一种情形，这里我处理为invoke节点要加上调用的函数作为一个图的节点,所以会有稍许变动
然后是返回一个invoke节点和调用函数的字典，用于后面连接整个apk的函数
输入为一个函数的行列表,不包括.method 和 .end method
输出为一个调用图
'''
def connect_opcode_graph_generator(method_line_list):
    # method对应的操作码图
    opcode_graph = nx.DiGraph()
    # 跳转标签的列表
    label_list = []
    # 表示接下来遍历到的pswitch是否是标签
    is_packed_switch = False
    # 表示上一个操作码
    last_opcode = ''
    # 表示起始操作码
    start_opcode = ''
    # 表示终止操作码
    end_opcode = ''
    # 表示invoke节点和调用的函数字典
    invoke_dict = {}
    for line in method_line_list:
        line = line.strip().replace("\n", "")
        line_list = line.split(" ")

        line_length = len(line_list)
        # 先判断是否是一个操作码
        if line_list[0] in all_opcode_list:
            if start_opcode == '':
                start_opcode = line_list[0]
            # 有前置节点
            if last_opcode != '':
                # 然后判断是否是跳转操作码,包含两类，goto,if和switch
                if line_list[0] in jump_opcode_list:
                    # 是否是if跳转
                    if line_list[0].startswith("if-"):
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = line_list[0]
                    # 是否是goto跳转
                    elif line_list[0].startswith("goto"):
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = ''
                    # 是否是switch跳转
                    elif line_list[0].startswith("packed-switch"):
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        last_opcode = line_list[0]
                # 非跳转操作码操作
                elif line_list[0].startswith("return"):
                    opcode_graph.add_edge(last_opcode, line_list[0])
                    end_opcode = line_list[0]
                    last_opcode = ''
                elif line_list[0].startswith("invoke-"):
                    invoke_opcode = line_list[0]+":"+line_list[line_length - 1]
                    opcode_graph.add_edge(last_opcode, invoke_opcode)
                    last_opcode = invoke_opcode
                    invoke_dict[invoke_opcode] = line_list[line_length - 1]
                else:
                    opcode_graph.add_edge(last_opcode, line_list[0])
                    last_opcode = line_list[0]
            # 没有前置节点
            else:
                # 然后判断是否是跳转操作码,包含两类，goto和if，switch正常按照其他操作码进行处理
                if line_list[0] in jump_opcode_list:
                    # 是否是if跳转
                    if line_list[0].startswith("if-"):
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = line_list[0]
                    # 是否是goto跳转
                    elif line_list[0].startswith("goto"):
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = ''
                elif line_list[0].startswith("return"):
                    end_opcode = line_list[0]
                    last_opcode = ''
                elif line_list[0].startswith("invoke-"):
                    invoke_opcode = line_list[0]+":"+line_list[line_length - 1]
                    last_opcode = invoke_opcode
                    invoke_dict[invoke_opcode] = line_list[line_length - 1]
                    if start_opcode.startswith("invoke-") and start_opcode.find(":") < 0:
                        start_opcode = invoke_opcode
                # 非跳转操作码操作
                else:
                    last_opcode = line_list[0]

        # 不是一个操作码
        elif check_is_label(line_list[0]):
            if line_list[0] not in label_list:
                label_list.append(line_list[0])
            # 先看是否有前置节点
            if last_opcode != '':
                # 再看是否是switch标签类型
                if line_list[0].startswith(":pswitch"):
                    if is_packed_switch:
                        opcode_graph.add_edge("packed-switch", line_list[0])
                    else:
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        last_opcode = line_list[0]
                # 其他正常处理
                else:
                    opcode_graph.add_edge(last_opcode, line_list[0])
                    last_opcode = line_list[0]
            # 没有前置节点
            else:
                # 再看是否是switch标签类型
                if line_list[0].startswith(":pswitch_"):
                    if is_packed_switch:
                        opcode_graph.add_edge("packed-switch", line_list[0])
                    else:
                        last_opcode = line_list[0]
                # 其他正常处理
                else:
                    last_opcode = line_list[0]
        elif line_list[0].startswith(".packed-switch"):
            is_packed_switch = True
            continue
        elif line_list[0].startswith(".end packed-switch"):
            is_packed_switch = False
            continue
    # print_opcode_graph(opcode_graph)

    # 删除label，调用label的操作码指向label的下一个节点
    for label in label_list:
        pre_list = []
        next_list = []
        presuccessors = opcode_graph.predecessors(label)
        # 调用点
        successors = opcode_graph.successors(label)
        # 将被调用点指向调用点
        for presuccessor in presuccessors:
            pre_list.append(presuccessor)

        for successor in successors:
            next_list.append(successor)

        for pre_node in pre_list:
            for next_node in next_list:
                opcode_graph.add_edge(pre_node, next_node)
        # 删除节点
        opcode_graph.remove_node(label)

    return start_opcode, end_opcode, opcode_graph, invoke_dict

'''
考虑函数间调用的实现,具体应用为考虑函数间调用的第二种情形
首先是invoke部分处理与第一种情形相似
然后是对于块的处理，暂时的想法是用函数的名字+自然数的形式来作为块的键，无跳转则处理为块
输入为一个函数的行列表,不包括.method 和 .end method
输出为一个调用图
'''
def block_opcode_graph_generator(method_name, method_line_list):
    # method对应的操作码图
    opcode_graph = nx.DiGraph()
    # 跳转标签的列表
    label_list = []
    # 表示接下来遍历到的pswitch是否是标签
    is_packed_switch = False
    # 表示上一个操作码
    last_opcode = ''
    # 表示起始操作码
    start_opcode = ''
    # 表示终止操作码
    end_opcode = ''
    # 表示invoke节点和调用的函数字典
    invoke_dict = {}
    # 定义一个自然数,标识这个块在函数的键
    block_id = 0
    # 定义一个块键，若已被加入图，id++
    block =  str(block_id) + ":"+ method_name
    for line in method_line_list:
        line = line.strip().replace("\n", "")
        line_list = line.split(" ")

        line_length = len(line_list)
        # 先判断是否是一个操作码
        if line_list[0] in all_opcode_list:
            if start_opcode == '':
                start_opcode = line_list[0]
            end_opcode = line_list[0]
            # 有前置节点
            if last_opcode != '':
                # 然后判断是否是跳转操作码,包含两类，goto,if和switch
                if line_list[0] in jump_opcode_list:
                    # 是否是if跳转
                    if line_list[0].startswith("if-"):
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = line_list[0]
                    # 是否是goto跳转
                    elif line_list[0].startswith("goto"):
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = ''
                    # 是否是switch跳转
                    elif line_list[0].startswith("packed-switch"):
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        last_opcode = line_list[0]
                    # 当遇到当前行为跳转操作码或者跳转标签时，块的id+1
                    block_id += 1
                    block = str(block_id) + ":" + method_name
                # 非跳转操作码操作
                elif line_list[0].startswith("return"):
                    opcode_graph.add_edge(last_opcode, line_list[0])
                    last_opcode = ''
                    block_id += 1
                    block = str(block_id) + ":" + method_name
                elif line_list[0].startswith("invoke-"):
                    invoke_opcode = line_list[0]+":"+line_list[line_length - 1]
                    opcode_graph.add_edge(last_opcode, invoke_opcode)
                    last_opcode = invoke_opcode
                    invoke_dict[invoke_opcode] = line_list[line_length - 1]
                    block_id += 1
                    block = str(block_id) + ":" + method_name
                else:
                    # 看前一个操作码是否是块
                    if check_string_is_number(last_opcode):
                        print(last_opcode + str(check_string_is_number(last_opcode)))
                        continue
                    else:
                        print(last_opcode + str(check_string_is_number(last_opcode)))
                        opcode_graph.add_edge(last_opcode, block)
                        last_opcode = block
                        block_id += 1
                        block = str(block_id) + ":" + method_name
            # 没有前置节点
            else:
                # 然后判断是否是跳转操作码,包含两类，goto和if，switch正常按照其他操作码进行处理
                if line_list[0] in jump_opcode_list:
                    # 是否是if跳转
                    if line_list[0].startswith("if-"):
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = line_list[0]
                    # 是否是goto跳转
                    elif line_list[0].startswith("goto"):
                        opcode_graph.add_edge(line_list[0], line_list[line_length - 1])
                        last_opcode = ''
                    # 当遇到当前行为跳转操作码或者跳转标签时，块的id+1
                    block_id += 1
                    block = str(block_id) + ":" + method_name
                elif line_list[0].startswith("return"):
                    last_opcode = ''
                    block_id += 1
                    block = str(block_id) + ":" + method_name
                elif line_list[0].startswith("invoke-"):
                    invoke_opcode = line_list[0]+":"+line_list[line_length - 1]
                    last_opcode = invoke_opcode
                    invoke_dict[invoke_opcode] = line_list[line_length - 1]
                    block_id += 1
                    block = str(block_id) + ":" + method_name
                # 非跳转操作码操作
                else:
                    last_opcode = block
                    block_id += 1
                    block = str(block_id) + ":" + method_name
        # 不是一个操作码
        elif check_is_label(line_list[0]):
            if line_list[0] not in label_list:
                label_list.append(line_list[0])
            # 先看是否有前置节点
            if last_opcode != '':
                # 再看是否是switch标签类型
                if line_list[0].startswith(":pswitch"):
                    if is_packed_switch:
                        opcode_graph.add_edge("packed-switch", line_list[0])
                    else:
                        opcode_graph.add_edge(last_opcode, line_list[0])
                        last_opcode = line_list[0]
                        block_id += 1
                        block = str(block_id) + ":" + method_name
                # 其他正常处理
                else:
                    opcode_graph.add_edge(last_opcode, line_list[0])
                    last_opcode = line_list[0]
                    block_id += 1
                    block = str(block_id) + ":" + method_name
            # 没有前置节点
            else:
                # 再看是否是switch标签类型
                if line_list[0].startswith(":pswitch_"):
                    if is_packed_switch:
                        opcode_graph.add_edge("packed-switch", line_list[0])
                    else:
                        last_opcode = line_list[0]
                        block_id += 1
                        block = str(block_id) + ":" + method_name
                # 其他正常处理
                else:
                    last_opcode = line_list[0]
                    block_id += 1
                    block = str(block_id) + ":" + method_name
        elif line_list[0].startswith(".packed-switch"):
            is_packed_switch = True
            continue
        elif line_list[0].startswith(".end packed-switch"):
            is_packed_switch = False
            block_id += 1
            block = str(block_id) + ":" + method_name
            continue
    # print_opcode_graph(opcode_graph)

    # 删除label，调用label的操作码指向label的下一个节点
    for label in label_list:
        pre_list = []
        next_list = []
        presuccessors = opcode_graph.predecessors(label)
        # 调用点
        successors = opcode_graph.successors(label)
        # 将被调用点指向调用点
        for presuccessor in presuccessors:
            pre_list.append(presuccessor)

        for successor in successors:
            next_list.append(successor)

        for pre_node in pre_list:
            for next_node in next_list:
                opcode_graph.add_edge(pre_node, next_node)
        # 删除节点
        opcode_graph.remove_node(label)

    return start_opcode, end_opcode, opcode_graph, invoke_dict



# 判断是否是goto if switch的标签
def check_is_label(label):
    if label.startswith(":goto_") and check_char_is_number(label[6]):
        return True
    elif label.startswith(":cond_") and check_char_is_number(label[6]):
        return True
    elif label.startswith(":pswitch_") and check_char_is_number(label[9]):
        return True
    else:
        return False

# 判断是否是数字
def check_char_is_number(c):
    if c == '0' or c == '1' or c == '2' or c == '3' or c == '4' or c == '5' or c == '6' or c == '7' or c == '8' or c == '9':
        return True
    else:
        return False

# 判断是否是数字
def check_string_is_number(c):
    if c.startswith('0') or c.startswith('1') or c.startswith('2') or c.startswith('3') or c.startswith('4') or c.startswith('5') or c.startswith('6') or c.startswith('7') or c.startswith('8') or c.startswith('9'):
        return True
    else:
        return False

# print图
def print_opcode_graph(opcode_graph):
    pos = nx.spring_layout(opcode_graph)
    nx.draw(opcode_graph, pos, with_labels=True)
    plt.show()









# 得到所有函数的行，然后分析得到每个函数的操作码图，然后返回一个字典
def get_opcode_graph(method_dict):
    graph_dict = {}
    for method in list(method_dict.keys()):
        print(method)
        start_opcode, end_opcode, opcode_graph, invoke_dict = block_opcode_graph_generator(method, method_dict[method])
        # start_opcode, end_opcode, opcode_graph, invoke_dict = connect_opcode_graph_generator(method_dict[method])
        graph_dict[method] = opcode_graph
        # 画图检查图
        print("start:"+start_opcode)
        print("end:" + end_opcode)
        print("invoke_dict:" + str(invoke_dict))
        print_opcode_graph(opcode_graph)
    return graph_dict

# 读取一个smali文件，分析其中的函数，得到每个函数的所有行
def get_lines_from_smali(smali_loc):
    f = open(smali_loc, "r", encoding="gbk")
    method_dict = {}
    method_line_list = None
    for line in f:
        line = line.strip()
        line_list = line.split(" ")
        if line.startswith(".method"):
            method_line_list = []
            method_dict[line_list[len(line_list) - 1]] = method_line_list
            continue
        elif line.startswith(".end method"):
            method_line_list = None
            continue
        elif method_line_list is not None:
            method_line_list.append(line)
    return method_dict

if __name__ == '__main__':

    # 先得到所有的操作码
    get_opcode(".\\opcodeContent\\allList.txt", ".\\opcodeContent\\jumpList.txt")
    # 得到一个smali文件的所有函数的行
    method_dict = get_lines_from_smali(".\\BackStackRecord.smali")
    # 运用第一种方法，得到所有的函数的操作码图
    opcode_graph_dict = get_unconnect_opcode_graph(method_dict)
    # 运用第二种方法，得到一个函数操作图
    # 运用第三种方法，得到一个函数操作图
